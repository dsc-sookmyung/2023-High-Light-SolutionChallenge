{
	"1": {
		"page_id": 1,
		"full_text": {
			"audio_url": "",
			"full_text": "5장 병행성: 상호배제와 동기화\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 40,
				"text": "5장 병행성: 상호배제와 동기화\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"2": {
		"page_id": 2,
		"full_text": {
			"audio_url": "",
			"full_text": "5장의 학습 목표\n• 병행성(concurrency)의 원리와 주요 용어를 이해한다.\n• 경쟁상태(race condition)의 문제점에 대해 이해한다.\n• 경쟁상태 해결을 위한 운영체제 고려사항을 이해한다.\n• 상호배제(mutual exclusion)의 필요성 및 이를 지원하\n기 위한 하드웨어 수준 접근방법을 이해한다.\n• 세마포어를 정의하고 동작 방식을 이해한다.\n• 모니터를 정의하고 동작 방식을 이해한다.\n• 메시지 전달을 이용한 상호배제 기법을 이해한다.\n• 상호배제 문제의 대표적인 예인 생산자/소비자 문제와\n판독자/기록자 문제를 이해하고 해결 방법을 이해한다.\n2\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "5장의 학습 목표\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 병행성(concurrency)의 원리와 주요 용어를 이해한다.\n• 경쟁상태(race condition)의 문제점에 대해 이해한다.\n• 경쟁상태 해결을 위한 운영체제 고려사항을 이해한다.\n• 상호배제(mutual exclusion)의 필요성 및 이를 지원하\n기 위한 하드웨어 수준 접근방법을 이해한다.\n• 세마포어를 정의하고 동작 방식을 이해한다.\n• 모니터를 정의하고 동작 방식을 이해한다.\n• 메시지 전달을 이용한 상호배제 기법을 이해한다.\n• 상호배제 문제의 대표적인 예인 생산자/소비자 문제와\n판독자/기록자 문제를 이해하고 해결 방법을 이해한다.\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "2\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"3": {
		"page_id": 3,
		"full_text": {
			"audio_url": "",
			"full_text": "목 차\n5.1 병행성 원리 (Principles of Concurrency) \n5.2 상호배제 (Mutual Exclusion): 하드웨어 지원\n5.3 세마포어 (Semaphore)\n5.4 모니터 (Monitor)\n5.5 메시지 전달 (Message Passing)\n5.6 판독자/기록자 (Readers/Writers) 문제\n3\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "목 차\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "5.1 병행성 원리 (Principles of Concurrency) \n5.2 상호배제 (Mutual Exclusion): 하드웨어 지원\n5.3 세마포어 (Semaphore)\n5.4 모니터 (Monitor)\n5.5 메시지 전달 (Message Passing)\n5.6 판독자/기록자 (Readers/Writers) 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "3\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"4": {
		"page_id": 4,
		"full_text": {
			"audio_url": "",
			"full_text": "5.1 병행성 원리\n• 멀티프로세스\n– 프로세스/쓰레드 관리를 위한 현대 운영체제의 설계 핵심 주제\n• Multiprogramming\n• Multiprocessing\n• Distributed Processing\n– Eg) 인터리빙, 오버랩핑\n• 동일한 문제 야기\n– Big Issue is Concurrency(병행성) \n• Managing the interaction of all of these processes\n4\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "5.1 병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 멀티프로세스\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 프로세스/쓰레드 관리를 위한 현대 운영체제의 설계 핵심 주제\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• Multiprogramming\n• Multiprocessing\n• Distributed Processing\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– Eg) 인터리빙, 오버랩핑\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• 동일한 문제 야기\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– Big Issue is Concurrency(병행성) \n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• Managing the interaction of all of these processes\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "4\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"5": {
		"page_id": 5,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 원리\n• 병행성: 다음과 같은 3가지 상황에서 발생\n다수의 응용\n다수의 활동 중인 응용들\n간에 처리시간의 동적\n공유를 위해\n멀티프로그래밍이 발전\n구조화된 응용\n모듈화된 설계 원칙과\n구조적인 프로그램이\n발전되면서 일부 응용이\n병행 프로세스의 집합\n운영체제 구조\n운영체제도 다수의\n프로세스와 쓰레드의\n집합으로 구현\n5\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 병행성: 다음과 같은 3가지 상황에서 발생\n"
			},
			{
				"audio_url": "",
				"font_size": 25,
				"text": "다수의 응용\n"
			},
			{
				"audio_url": "",
				"font_size": 14,
				"text": "다수의 활동 중인 응용들\n간에 처리시간의 동적\n공유를 위해\n멀티프로그래밍이 발전\n"
			},
			{
				"audio_url": "",
				"font_size": 25,
				"text": "구조화된 응용\n"
			},
			{
				"audio_url": "",
				"font_size": 14,
				"text": "모듈화된 설계 원칙과\n구조적인 프로그램이\n발전되면서 일부 응용이\n병행 프로세스의 집합\n"
			},
			{
				"audio_url": "",
				"font_size": 25,
				"text": "운영체제 구조\n"
			},
			{
				"audio_url": "",
				"font_size": 14,
				"text": "운영체제도 다수의\n프로세스와 쓰레드의\n집합으로 구현\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "5\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"6": {
		"page_id": 6,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 원리\n• 병행 처리의 문제점\n– 전역 자원의 공유가 어렵다.\n– 운영체제가 자원을 최적으로 할당하기 어렵다.\n– 프로그래밍 오류를 찾아내는 것이 어렵다.\n• 인터리빙이나 오버래핑으로 인해 발생하는 문제점은\n단일처리기 시스템에서나 다중처리기 시스템에서 동일\n– 단일처리기: 프로세스 수행의 상대적인 속도 예측이 어려움\n• 다른 프로세스의 행동에 종속\n• OS의 스케줄링 정책에 의존\n• OS의 인터럽트 처리 방법에 따라 달라짐\n6\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 병행 처리의 문제점\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 전역 자원의 공유가 어렵다.\n– 운영체제가 자원을 최적으로 할당하기 어렵다.\n– 프로그래밍 오류를 찾아내는 것이 어렵다.\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 인터리빙이나 오버래핑으로 인해 발생하는 문제점은\n단일처리기 시스템에서나 다중처리기 시스템에서 동일\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 단일처리기: 프로세스 수행의 상대적인 속도 예측이 어려움\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• 다른 프로세스의 행동에 종속\n• OS의 스케줄링 정책에 의존\n• OS의 인터럽트 처리 방법에 따라 달라짐\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "6\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"7": {
		"page_id": 7,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 원리\n• 병행성과 관련된 주요 용어\n 그 외: 공유 자원(Shared Resource), 동기화(Synchronization)\n7\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 병행성과 관련된 주요 용어\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " 그 외: 공유 자원(Shared Resource), 동기화(Synchronization)\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "7\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"8": {
		"page_id": 8,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 원리\n• 병행성의 다른 예들\n– 공유 함수(shared functions)\n// shared functions\nvoid echo()\n{\nchin = getchar();\nchout = chin;\nputchar(chout); \n}\nProcess P1\n.\nchin = getchar();\n.\nchout = chin;\nputchar(chout);\n.\n.\nProcess P2\n.\n.\nchin = getchar();\nchout = chin;\n.\nputchar(chout);\n.\n– 연관된 공유 데이터 집합(a = b 라는 일관성 유지 필요)\n// coordinated data set\nProcess P1\na = a + 1;\nb = b + 1;\n…\nProcess P2\nb = b * 2;\na = a * 2;\n// Real Execution  \n…\na = a + 1;\nb = b * 2;\nb = b + 1;\na = a * 2;\n…\n8\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 병행성의 다른 예들\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 공유 함수(shared functions)\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "// shared functions\nvoid echo()\n{\nchin = getchar();\nchout = chin;\nputchar(chout); \n}\nProcess P1\n.\nchin = getchar();\n.\nchout = chin;\nputchar(chout);\n.\n.\nProcess P2\n.\n.\nchin = getchar();\nchout = chin;\n.\nputchar(chout);\n.\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 연관된 공유 데이터 집합(a = b 라는 일관성 유지 필요)\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "8\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"9": {
		"page_id": 9,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 원리\n• 경쟁상태(Race condition)\n– 다중 프로세스/쓰레드가 공유 데이터를 읽거나 쓸 때 발생\n– 최종 결과는 수행의 순서에 의해 결정됨\n• 경쟁(race)의 패자(loser)가 가장 마지막으로 데이터를 수정하며, 결국\n최종 결과를 결정함\n• 운영체제 고려사항\n다양한 프로세스의 행위를 추적할 수 있어야 함\n각 프로세스에게 자원을 할당하거나 반납 받을 수 있어야 함\n한 프로세스가 소유한 자원이나 데이터를 다른 프로세스의\n간섭으로부터 보호할 수 있어야 함\n수행 결과가 프로세스들의 수행 순서와 독립적일 수 있도록\n보장해야 함\n9\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 경쟁상태(Race condition)\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 다중 프로세스/쓰레드가 공유 데이터를 읽거나 쓸 때 발생\n– 최종 결과는 수행의 순서에 의해 결정됨\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• 경쟁(race)의 패자(loser)가 가장 마지막으로 데이터를 수정하며, 결국\n최종 결과를 결정함\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 운영체제 고려사항\n"
			},
			{
				"audio_url": "",
				"font_size": 14,
				"text": "다양한 프로세스의 행위를 추적할 수 있어야 함\n각 프로세스에게 자원을 할당하거나 반납 받을 수 있어야 함\n한 프로세스가 소유한 자원이나 데이터를 다른 프로세스의\n간섭으로부터 보호할 수 있어야 함\n수행 결과가 프로세스들의 수행 순서와 독립적일 수 있도록\n보장해야 함\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "9\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"10": {
		"page_id": 10,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 원리\n• 프로세스 상호작용: 경쟁, 공유, 통신\n10\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 프로세스 상호작용: 경쟁, 공유, 통신\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "10\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"11": {
		"page_id": 11,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 원리\n• 자원 경쟁\n– 병렬 프로세스들이 같은 자원을 사용하려고 경쟁하면 충돌이\n발생한다.\n– Eg. I/O 장치, 메모리, 처리기 시간, 클락 등\n프로세스들이 경쟁하면 다음 3가지 제어\n문제가 발생함\n• 상호배제 (mutual exclusion)\n• 교착상태 (deadlock)\n• 기아 (starvation)\n11\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 원리\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 자원 경쟁\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 병렬 프로세스들이 같은 자원을 사용하려고 경쟁하면 충돌이\n발생한다.\n– Eg. I/O 장치, 메모리, 처리기 시간, 클락 등\n"
			},
			{
				"audio_url": "",
				"font_size": 28,
				"text": "프로세스들이 경쟁하면 다음 3가지 제어\n문제가 발생함\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 상호배제 (mutual exclusion)\n• 교착상태 (deadlock)\n• 기아 (starvation)\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "11\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"12": {
		"page_id": 12,
		"full_text": {
			"audio_url": "",
			"full_text": "상호배제\n• 상호배제(mutual exclusion) 요구조건\n– 어느 한 순간에는 오직 하나의 프로세스만이 임계영역(critical \nsection)에 진입할 수 있다. \n– 임계영역이 아닌 곳에서 수행이 멈춘 프로세스는 다른 프로세스\n의 수행을 간섭해서는 안 된다.\n– 임계영역에 접근하고자 하는 프로세스의 수행이 무한히 미뤄져\n서는 안 된다. 즉, 교착상태(deadlock) 및 기아(starvation)가 일어\n나지 않아야 한다.\n– 임계영역이 비어 있을 때, 임계영역에 진입하려고 하는 프로세스\n가 지연되어서는 안 된다.\n– 프로세서의 개수나 상대적인 프로세스 수행 속도에 대한 가정은\n없어야 한다. \n– 프로세스는 유한 시간 동안만 임계영역에 존재할 수 있다. \n12\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "상호배제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 상호배제(mutual exclusion) 요구조건\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 어느 한 순간에는 오직 하나의 프로세스만이 임계영역(critical \nsection)에 진입할 수 있다. \n– 임계영역이 아닌 곳에서 수행이 멈춘 프로세스는 다른 프로세스\n의 수행을 간섭해서는 안 된다.\n– 임계영역에 접근하고자 하는 프로세스의 수행이 무한히 미뤄져\n서는 안 된다. 즉, 교착상태(deadlock) 및 기아(starvation)가 일어\n나지 않아야 한다.\n– 임계영역이 비어 있을 때, 임계영역에 진입하려고 하는 프로세스\n가 지연되어서는 안 된다.\n– 프로세서의 개수나 상대적인 프로세스 수행 속도에 대한 가정은\n없어야 한다. \n– 프로세스는 유한 시간 동안만 임계영역에 존재할 수 있다. \n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "12\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"13": {
		"page_id": 13,
		"full_text": {
			"audio_url": "",
			"full_text": "상호배제\n• 상호배제 해결방법\n– 어느 한 순간에는 오직 하나의 프로세스만이 임계영역에 진입\n– Illustration of Mutual Exclusion\n13\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "상호배제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 상호배제 해결방법\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 어느 한 순간에는 오직 하나의 프로세스만이 임계영역에 진입\n– Illustration of Mutual Exclusion\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "13\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"14": {
		"page_id": 14,
		"full_text": {
			"audio_url": "",
			"full_text": "상호배제\n• entercritical(), exitcritical() 구현 방법\n– 소프트웨어적 접근방법\n• 수행 부하가 높고, 논리적 오류의 위험성이 크다.\n– 하드웨어 지원\n• 인터럽트 금지(오버헤드가 크다.)\n• 특별한 기계 명령어: Test and Set, Exchange\n– 세마포어\n– 모니터\n– 메시지 전달\n14\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "상호배제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• entercritical(), exitcritical() 구현 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 소프트웨어적 접근방법\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• 수행 부하가 높고, 논리적 오류의 위험성이 크다.\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 하드웨어 지원\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• 인터럽트 금지(오버헤드가 크다.)\n• 특별한 기계 명령어: Test and Set, Exchange\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 세마포어\n– 모니터\n– 메시지 전달\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "14\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"15": {
		"page_id": 15,
		"full_text": {
			"audio_url": "",
			"full_text": "5.2 하드웨어 지원\n• 인터럽트 금지\n// 인터럽트 금지\nwhile (true)\n{\n/* disable interrupt */\n/* critical section */\n/* enable interrupt */\n/* remainder */\n}\n• 특별한 기계 명령어\n multiprocessor??\n// 특별한 기계 명령어: compare & swap\nint compare_and_swap (int *word, int testval, int newval) \n{\n// 특별한 기계 명령어: exchange\nvoid exchange (int *register, int *memory) \n{\nint oldval; \noldval = *word;\nif (oldval ==  testval) \n*word = newval;\nreturn oldval;\n}\nint temp;\ntemp = *memory;\n*memory = *register;\n*register = temp;\n}\n// XCHG in IA, SWAP in ARM architecture\n 원자적 연산(atomic operation)\n15\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "5.2 하드웨어 지원\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 인터럽트 금지\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "// 인터럽트 금지\nwhile (true)\n{\n/* disable interrupt */\n/* critical section */\n/* enable interrupt */\n/* remainder */\n}\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 특별한 기계 명령어\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " multiprocessor??\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "// 특별한 기계 명령어: compare & swap\nint compare_and_swap (int *word, int testval, int newval) \n{\n// 특별한 기계 명령어: exchange\nvoid exchange (int *register, int *memory) \n{\nint oldval; \noldval = *word;\nif (oldval ==  testval) \n*word = newval;\nreturn oldval;\n}\nint temp;\ntemp = *memory;\n*memory = *register;\n*register = temp;\n}\n// XCHG in IA, SWAP in ARM architecture\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " 원자적 연산(atomic operation)\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "15\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"16": {
		"page_id": 16,
		"full_text": {
			"audio_url": "",
			"full_text": "하드웨어 지원\n• 특별한 기계 명령어 사용 예\n16\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "하드웨어 지원\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 특별한 기계 명령어 사용 예\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "16\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"17": {
		"page_id": 17,
		"full_text": {
			"audio_url": "",
			"full_text": "하드웨어 지원\n• 특별한 기계 명령어 장점\n– 임의 개수의 프로세스에 적용 가능\n– 단일 프로세서와 공유 메모리 기반 다중 프로세서에 모두 적용 가능\n– 간단하고 검증하기 쉬움\n– 서로 다른 변수를 사용하면 다중 임계영역 지원\n• 특별한 기계 명령어 단점\n– 바쁜 대기(Busy-waiting) \n– 기아상태 발생 가능\n– 교착상태 발생 가능\n• 예를 들어 우선 순위가 낮은 프로세스가 임계영역에 진입한 상태이고 우선 순\n위가 높은 프로세스가 그 임계영역에 진입하기 위해 바쁜 대기를 하고 있다면\n교착상태 발생\n17\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "하드웨어 지원\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 특별한 기계 명령어 장점\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "– 임의 개수의 프로세스에 적용 가능\n– 단일 프로세서와 공유 메모리 기반 다중 프로세서에 모두 적용 가능\n– 간단하고 검증하기 쉬움\n– 서로 다른 변수를 사용하면 다중 임계영역 지원\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 특별한 기계 명령어 단점\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "– 바쁜 대기(Busy-waiting) \n– 기아상태 발생 가능\n– 교착상태 발생 가능\n"
			},
			{
				"audio_url": "",
				"font_size": 16,
				"text": "• 예를 들어 우선 순위가 낮은 프로세스가 임계영역에 진입한 상태이고 우선 순\n위가 높은 프로세스가 그 임계영역에 진입하기 위해 바쁜 대기를 하고 있다면\n교착상태 발생\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "17\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"18": {
		"page_id": 18,
		"full_text": {
			"audio_url": "",
			"full_text": "병행성 기법\n18\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "병행성 기법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "18\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"19": {
		"page_id": 19,
		"full_text": {
			"audio_url": "",
			"full_text": "5.3 세마포어\n• 세마포어(semaphore) 정의\n– 상호 배제를 운영체제와 프로그래밍 언어 수준에서 지원하는\n메커니즘\n– 블록(수면)과 깨움을 지원\n– 세마포어는 정수 값을 갖는 변수로 다음 3가지 인터페이스를 통\n해 접근할 수 있다.\n• 초기화 연산(Initialize operation): 세마포어 값을 음이 아닌 값으로\n초기화한다. \n• 대기 연산(Wait operation): 세마포어 값을 감소시킨다. 값이 음수이\n면 호출한 프로세스는 블록 된다. 음수가 아니면 프로세스는 계속\n수행될 수 있다.\n• 시그널 연산(Signal operation): 세마포어 값을 증가시킨다. 값이 양\n수가 아니면 블록된 프로세스를 깨운다.\n19\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "5.3 세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어(semaphore) 정의\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 상호 배제를 운영체제와 프로그래밍 언어 수준에서 지원하는\n메커니즘\n– 블록(수면)과 깨움을 지원\n– 세마포어는 정수 값을 갖는 변수로 다음 3가지 인터페이스를 통\n해 접근할 수 있다.\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• 초기화 연산(Initialize operation): 세마포어 값을 음이 아닌 값으로\n초기화한다. \n• 대기 연산(Wait operation): 세마포어 값을 감소시킨다. 값이 음수이\n면 호출한 프로세스는 블록 된다. 음수가 아니면 프로세스는 계속\n수행될 수 있다.\n• 시그널 연산(Signal operation): 세마포어 값을 증가시킨다. 값이 양\n수가 아니면 블록된 프로세스를 깨운다.\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "19\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"20": {
		"page_id": 20,
		"full_text": {
			"audio_url": "",
			"full_text": "카운팅(counting) 세마포어\n• 여러 개의 공유 자원에 대한 액세스를 제어할 목적\n– 일반 세마포어에 해당\n P, V operations\nProberen: to try\nVerhogen: to increase\n20\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "카운팅(counting) 세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 여러 개의 공유 자원에 대한 액세스를 제어할 목적\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 일반 세마포어에 해당\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " P, V operations\nProberen: to try\nVerhogen: to increase\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "20\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"21": {
		"page_id": 21,
		"full_text": {
			"audio_url": "",
			"full_text": "이진(binary) 세마포어\n• 이진 세마포어\n– mutex의 역할\n21\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "이진(binary) 세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 이진 세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– mutex의 역할\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "21\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"22": {
		"page_id": 22,
		"full_text": {
			"audio_url": "",
			"full_text": "세마포어\n• 세마포어를 이용한 상호배제\n22\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어를 이용한 상호배제\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "22\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"23": {
		"page_id": 23,
		"full_text": {
			"audio_url": "",
			"full_text": "세마포어\n• 세마포어를 이용한 상호배제 동작 예 1\n– 가정: 3개의 프로세스 존재\n 세마포어 변수의 값과 블록된 프로세스 개수와의 관계는?\n23\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어를 이용한 상호배제 동작 예 1\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 가정: 3개의 프로세스 존재\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " 세마포어 변수의 값과 블록된 프로세스 개수와의 관계는?\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "23\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"24": {
		"page_id": 24,
		"full_text": {
			"audio_url": "",
			"full_text": "세마포어\n• 세마포어를 이용한 상호배\n제 동작 예 2\n– 가정: 프로세스 A,B,C는 프로\n세스 D가 생산한 데이터를\n소비\n• strong semaphore vs. \nweak semaphore\n24\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어를 이용한 상호배\n제 동작 예 2\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 가정: 프로세스 A,B,C는 프로\n세스 D가 생산한 데이터를\n소비\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• strong semaphore vs. \nweak semaphore\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "24\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"25": {
		"page_id": 25,
		"full_text": {
			"audio_url": "",
			"full_text": "세마포어\n• 세마포어의 특징\n프로세스가 블록될지 여부를\n세마포어를 감소시키기\n전까지 알 수 없다.\n프로세스가 세마포어를\n증가시키고 블록되어 있던\n프로세스를 깨우면, 이 두\n프로세스 모두 수행가능\n상태가 된다. 단일처리기\n시스템에서 이 두 프로세스\n중에 누가 먼저 수행될 지 알\n수 없다.\n세마포어에 시그널을 보낼 때, \n다른 프로세스가 대기 중인지\n알 필요가 없다. 즉, 깨어나는\n프로세스는 없거나\n하나이거나 이다.\n25\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어의 특징\n"
			},
			{
				"audio_url": "",
				"font_size": 14,
				"text": "프로세스가 블록될지 여부를\n세마포어를 감소시키기\n전까지 알 수 없다.\n프로세스가 세마포어를\n증가시키고 블록되어 있던\n프로세스를 깨우면, 이 두\n프로세스 모두 수행가능\n상태가 된다. 단일처리기\n시스템에서 이 두 프로세스\n중에 누가 먼저 수행될 지 알\n수 없다.\n세마포어에 시그널을 보낼 때, \n다른 프로세스가 대기 중인지\n알 필요가 없다. 즉, 깨어나는\n프로세스는 없거나\n하나이거나 이다.\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "25\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"26": {
		"page_id": 26,
		"full_text": {
			"audio_url": "",
			"full_text": "생산자/소비자 문제\n• 생산자/소비자 (producer/consumer) 문제 정의\n– 병행 수행되는 생산자와 소비자, 생산된 item을 버퍼에 저장\n• 한 순간에 하나의 생산자 또는 소비자만 버퍼에 접근 가능\n• 생산자는 가득 찬 버퍼에 저장하면 안됨. \n• 또한 소비자는 빈 버퍼에서 꺼내면 안됨\n– 버전 1: 무한 공유 버퍼\n// 생산자 의사 코드\nproducer:\nwhile (true) {\n/* produce item v */\nb[in] = v;\nin++; \n}\n// 소비자 의사 코드\nconsumer:\nwhile (true) {\nwhile (in <= out) \n/*do  nothing */;\nw = b[out];\nout++; \n/* consume item w */\n}\n26\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "생산자/소비자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 생산자/소비자 (producer/consumer) 문제 정의\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 병행 수행되는 생산자와 소비자, 생산된 item을 버퍼에 저장\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• 한 순간에 하나의 생산자 또는 소비자만 버퍼에 접근 가능\n• 생산자는 가득 찬 버퍼에 저장하면 안됨. \n• 또한 소비자는 빈 버퍼에서 꺼내면 안됨\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 버전 1: 무한 공유 버퍼\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "26\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"27": {
		"page_id": 27,
		"full_text": {
			"audio_url": "",
			"full_text": "생산자/소비자 문제\n• 이진 세마포어를 이용한 방법: 부정확한 방법\n27\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "생산자/소비자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 이진 세마포어를 이용한 방법: 부정확한 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "27\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"28": {
		"page_id": 28,
		"full_text": {
			"audio_url": "",
			"full_text": "생산자/소비자 문제\n• 이진 세마포어를 이용한 방법: 부정확한 방법\n28\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "생산자/소비자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 이진 세마포어를 이용한 방법: 부정확한 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "28\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"29": {
		"page_id": 29,
		"full_text": {
			"audio_url": "",
			"full_text": "생산자/소비자 문제\n• 이진 세마포어를 이용한 방법: 정확한 방법\n29\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "생산자/소비자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 이진 세마포어를 이용한 방법: 정확한 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "29\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"30": {
		"page_id": 30,
		"full_text": {
			"audio_url": "",
			"full_text": "생산자/소비자 문제\n• 무한 버퍼에서 범용 세마포어를 이용한 해결 방법\n30\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "생산자/소비자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 무한 버퍼에서 범용 세마포어를 이용한 해결 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "30\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"31": {
		"page_id": 31,
		"full_text": {
			"audio_url": "",
			"full_text": "생산자/소비자 문제\n• 버전 2\n– 병행 수행되는 생산자와 소비자\n– 유한 공유 버퍼\n// 생산자 의사 코드\nproducer:\nwhile (true) {\n// 소비자 의사 코드\nconsumer:\nwhile (true) {\n/* produce item v */\nwhile ((in + 1) % n == out) \n/* do nothing */;\nb[in] = v;\nin = (in + 1) % n\nwhile (in == out)\n/* do nothing */;\nw = b[out];\nout = (out + 1) % n;\n/* consume item w */\n}\n}\n31\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "생산자/소비자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 버전 2\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 병행 수행되는 생산자와 소비자\n– 유한 공유 버퍼\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "31\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"32": {
		"page_id": 32,
		"full_text": {
			"audio_url": "",
			"full_text": "생산자/소비자 문제\n• 유한 버퍼에서 범용 세마포어를 이용한 해결 방법\n32\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "생산자/소비자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 유한 버퍼에서 범용 세마포어를 이용한 해결 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "32\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"33": {
		"page_id": 33,
		"full_text": {
			"audio_url": "",
			"full_text": "세마포어 구현\n• semWait와 semSignal은 원자적으로 구현되어야 함\n• 하드웨어 또는 펌웨어로 구현 가능\n• Dekker’s 또는 Peterson’s 알고리즘 같은 소프트웨어적\n인 기법으로도 구현 가능\n• 상호 배제를 위해 하드웨어 지원 기법 중에 하나를 사용\n33\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "세마포어 구현\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• semWait와 semSignal은 원자적으로 구현되어야 함\n• 하드웨어 또는 펌웨어로 구현 가능\n• Dekker’s 또는 Peterson’s 알고리즘 같은 소프트웨어적\n인 기법으로도 구현 가능\n• 상호 배제를 위해 하드웨어 지원 기법 중에 하나를 사용\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "33\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"34": {
		"page_id": 34,
		"full_text": {
			"audio_url": "",
			"full_text": "세마포어 구현\n• 세마포어 구현 예\n 원자성(atomicity)\n34\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "세마포어 구현\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어 구현 예\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " 원자성(atomicity)\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "34\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"35": {
		"page_id": 35,
		"full_text": {
			"audio_url": "",
			"full_text": "5.4 모니터\n• 모니터 (Monitor)의 정의\n– 상호배제를 위한 소프트웨어 모듈 (프로그래밍 언어 수준에서\n제공)\n• Concurrent-Pascal, Pascal-Plus, Module-2/3, Java 등에서 지원\n– 세마포어처럼 상호 배제 기능 제공, but 사용이 훨씬 쉽다.\n• 특징\n– 지역 변수는 모니터 내부에서만 접근 가능\n– 프로세스는 모니터 프로시저 중 하나를 호출함으로써 모니터 내\n부로 진입\n– 한 시점에 단 하나의 프로세스만 모니터 내부에서 수행 가능\n35\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "5.4 모니터\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 모니터 (Monitor)의 정의\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 상호배제를 위한 소프트웨어 모듈 (프로그래밍 언어 수준에서\n제공)\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• Concurrent-Pascal, Pascal-Plus, Module-2/3, Java 등에서 지원\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 세마포어처럼 상호 배제 기능 제공, but 사용이 훨씬 쉽다.\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 특징\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 지역 변수는 모니터 내부에서만 접근 가능\n– 프로세스는 모니터 프로시저 중 하나를 호출함으로써 모니터 내\n부로 진입\n– 한 시점에 단 하나의 프로세스만 모니터 내부에서 수행 가능\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "35\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"36": {
		"page_id": 36,
		"full_text": {
			"audio_url": "",
			"full_text": "신호 기반 모니터\n• 구조\n– 하나 또는 그 이상의 프로시저\n– 지연변수\n– 조건변수\n• 동기화를 위해 조건 변수\n(Condition variables) 사용\n– 모니터 내부에서 사용\n– 다음 두 함수로 접근\n• cwait(c): 호출한 프로세스를\n조건 c에서 일시 중지 시킨다.\n• csignal(c): cwait에 의해서 중\n지되었던 프로세스를 재개시\n킨다. \n36\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "신호 기반 모니터\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "• 구조\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "– 하나 또는 그 이상의 프로시저\n– 지연변수\n– 조건변수\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "• 동기화를 위해 조건 변수\n(Condition variables) 사용\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "– 모니터 내부에서 사용\n"
			},
			{
				"audio_url": "",
				"font_size": 16,
				"text": "– 다음 두 함수로 접근\n• cwait(c): 호출한 프로세스를\n조건 c에서 일시 중지 시킨다.\n• csignal(c): cwait에 의해서 중\n지되었던 프로세스를 재개시\n킨다. \n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "36\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"37": {
		"page_id": 37,
		"full_text": {
			"audio_url": "",
			"full_text": "신호 기반 모니터\n• 모니터를 이용한 생산자/소비자 문제 해결 방법\n37\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "신호 기반 모니터\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 모니터를 이용한 생산자/소비자 문제 해결 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "37\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"38": {
		"page_id": 38,
		"full_text": {
			"audio_url": "",
			"full_text": "신호 기반 모니터\n• 모니터를 이용한 생산자/소비자 문제 해결 방법(계속)\n38\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "신호 기반 모니터\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 모니터를 이용한 생산자/소비자 문제 해결 방법(계속)\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "38\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"39": {
		"page_id": 39,
		"full_text": {
			"audio_url": "",
			"full_text": "Mesa 모니터\n• 변경 사항\n– csignal()  cnotify()\n– if  while\n39\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "Mesa 모니터\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 변경 사항\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– csignal()  cnotify()\n– if  while\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "39\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"40": {
		"page_id": 40,
		"full_text": {
			"audio_url": "",
			"full_text": "5.5 메시지 전달\n• 메시지 전달(message passing) 인터페이스\n– send (destination, message)\n– receive (source, message)\n– 기본적으로 정보 교환을 위해 사용\n– 또한 상호배제와 동기화를 위해 사용 가능\n mailbox (port)\n blocking operation\n40\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "5.5 메시지 전달\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 메시지 전달(message passing) 인터페이스\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "– send (destination, message)\n– receive (source, message)\n– 기본적으로 정보 교환을 위해 사용\n– 또한 상호배제와 동기화를 위해 사용 가능\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": " mailbox (port)\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " blocking operation\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "40\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"41": {
		"page_id": 41,
		"full_text": {
			"audio_url": "",
			"full_text": "메시지 전달\n• 관련 용어\n– Blocking, nonblocking\n– Addressing\n• Direct, indirect \n– Message format\n– Queuing discipline\n41\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "메시지 전달\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 관련 용어\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– Blocking, nonblocking\n– Addressing\n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": "• Direct, indirect \n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– Message format\n– Queuing discipline\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "41\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"42": {
		"page_id": 42,
		"full_text": {
			"audio_url": "",
			"full_text": "메시지 전달\n• 동기화\n42\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "메시지 전달\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 동기화\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "42\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"43": {
		"page_id": 43,
		"full_text": {
			"audio_url": "",
			"full_text": "메시지 전달\n• 메시지 전달을 이용한 상호 배제\n43\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "메시지 전달\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 메시지 전달을 이용한 상호 배제\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "43\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"44": {
		"page_id": 44,
		"full_text": {
			"audio_url": "",
			"full_text": "메시지 전달\n• 메시지 전달을 이용한 생산자/소비자 문제 해결 방법\n44\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "메시지 전달\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 메시지 전달을 이용한 생산자/소비자 문제 해결 방법\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "44\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"45": {
		"page_id": 45,
		"full_text": {
			"audio_url": "",
			"full_text": "5.6 판독자/기록자 문제\n• 판독자/기록자(readers/writers) 문제 정의\n– 병행 수행되는 판독자와 기록자\n– 공유 자원 (파일, 데이터베이스)\n• 요구 조건\n– 여러 판독자들이 공유 데이터를 동시에 읽을 수 있다. \n– 한 시점에 오직 하나의 기록자만 공유 데이터를 변경할 수 있다.\n– 기록자가 데이터를 변경하고 있는 동안 판독자가 그 데이터를\n읽을 수 없다. \n 생산자/소비자 문제와 차이점은? \n45\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "5.6 판독자/기록자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 판독자/기록자(readers/writers) 문제 정의\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 병행 수행되는 판독자와 기록자\n– 공유 자원 (파일, 데이터베이스)\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 요구 조건\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 여러 판독자들이 공유 데이터를 동시에 읽을 수 있다. \n– 한 시점에 오직 하나의 기록자만 공유 데이터를 변경할 수 있다.\n– 기록자가 데이터를 변경하고 있는 동안 판독자가 그 데이터를\n읽을 수 없다. \n"
			},
			{
				"audio_url": "",
				"font_size": 18,
				"text": " 생산자/소비자 문제와 차이점은? \n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "45\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"46": {
		"page_id": 46,
		"full_text": {
			"audio_url": "",
			"full_text": "판독자/기록자 문제\n• 세마포어를 이용한 해결 방법: 판독자 우선\n46\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "판독자/기록자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어를 이용한 해결 방법: 판독자 우선\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "46\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"47": {
		"page_id": 47,
		"full_text": {
			"audio_url": "",
			"full_text": "판독자/기록자 문제\n• 세마포어를 이용한 해결\n방법: 기록자 우선\n– x: readcount 보호\n– rsem: writer가 먼저 들어가\n있을 때 첫 번째 reader가 기\n다리는 세마포어\n– z: writer가 먼저 들어가 있을\n때 두 번째 이후의 reader가\n기다리는 세마포어\n– y: writecount 보호\n– wsem: reader건 writer건 먼\n저 들어온 프로세스가 갖는\n세마포어\n47\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "판독자/기록자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어를 이용한 해결\n방법: 기록자 우선\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– x: readcount 보호\n– rsem: writer가 먼저 들어가\n있을 때 첫 번째 reader가 기\n다리는 세마포어\n– z: writer가 먼저 들어가 있을\n때 두 번째 이후의 reader가\n기다리는 세마포어\n– y: writecount 보호\n– wsem: reader건 writer건 먼\n저 들어온 프로세스가 갖는\n세마포어\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "47\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"48": {
		"page_id": 48,
		"full_text": {
			"audio_url": "",
			"full_text": "판독자/기록자 문제\n• 세마포어를 이용한 해결 방법: 기록자 우선\n– 프로세스 대기 상태\n48\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "판독자/기록자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 24,
				"text": "• 세마포어를 이용한 해결 방법: 기록자 우선\n"
			},
			{
				"audio_url": "",
				"font_size": 20,
				"text": "– 프로세스 대기 상태\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "48\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"49": {
		"page_id": 49,
		"full_text": {
			"audio_url": "",
			"full_text": "메시지 전달을 이용한 판독자/기록자 문제\n• 기록자 우선이라고 가정\n– 기록자나 판독자는 제어기에게 요청 메시지를 보내고\n– 제어기로부터 OK를 받으면 임계영역으로 진입\n– 빠져나올 때 finished 메시지를 보내 나왔음을 알림.\n– 제어기는 쓰기 요청 메시지를 먼저 처리\n• count: 상호배제 구현에 활용되는 변수\n– 최대 가능한 판독자의 수보다 큰 수로 초기화되어 있음\n– 다음의 예에서는 100으로 초기화 되어 있음\n– count > 0: 현재 대기 중인 writer는 없는 상태\n– count = 100: 현재 활동 중인 reader가 없는 상태\n– 0 < count < 100: 현재 활동 중인 reader가 있는 상태\n– count < 0: writer가 요청을 했고, 활동 중인 모든 reader가 수행을\n마칠 때까지 기다리는 중. 따라서 reader의 완료 메시지만 서비스.\n– count = 0: 대기하던 writer 요청을 재개시킬 수 있는 상태\n49\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "메시지 전달을 이용한 판독자/기록자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 22,
				"text": "• 기록자 우선이라고 가정\n"
			},
			{
				"audio_url": "",
				"font_size": 19,
				"text": "– 기록자나 판독자는 제어기에게 요청 메시지를 보내고\n– 제어기로부터 OK를 받으면 임계영역으로 진입\n– 빠져나올 때 finished 메시지를 보내 나왔음을 알림.\n– 제어기는 쓰기 요청 메시지를 먼저 처리\n"
			},
			{
				"audio_url": "",
				"font_size": 22,
				"text": "• count: 상호배제 구현에 활용되는 변수\n"
			},
			{
				"audio_url": "",
				"font_size": 19,
				"text": "– 최대 가능한 판독자의 수보다 큰 수로 초기화되어 있음\n– 다음의 예에서는 100으로 초기화 되어 있음\n– count > 0: 현재 대기 중인 writer는 없는 상태\n– count = 100: 현재 활동 중인 reader가 없는 상태\n– 0 < count < 100: 현재 활동 중인 reader가 있는 상태\n– count < 0: writer가 요청을 했고, 활동 중인 모든 reader가 수행을\n마칠 때까지 기다리는 중. 따라서 reader의 완료 메시지만 서비스.\n– count = 0: 대기하던 writer 요청을 재개시킬 수 있는 상태\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "49\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	},
	"50": {
		"page_id": 50,
		"full_text": {
			"audio_url": "",
			"full_text": "메시지 전달을 이용한 판독자/기록자 문제\n50\n"
		},
		"text": [
			{
				"audio_url": "",
				"font_size": 32,
				"text": "메시지 전달을 이용한 판독자/기록자 문제\n"
			},
			{
				"audio_url": "",
				"font_size": 12,
				"text": "50\n"
			}
		],
		"image": {
			"img_idx": 1,
			"audio_url": "",
			"img_url": ""
		}
	}
}